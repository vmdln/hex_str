pub fn parse(msb: u8, lsb: u8) -> Option<u8> {
    #[rustfmt::skip]
    static HEX_LSB: [i16; 256] = [
        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
         0,   1,   2,   3,   4,   5,   6,   7,   8,   9, -1, -1, -1, -1, -1, -1,
        -1,  10,  11,  12,  13,  14,  15,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
        -1,  10,  11,  12,  13,  14,  15,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
    ];

    #[rustfmt::skip]
    static HEX_MSB: [i16; 256] = [
        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
         0,  16,  32,  48,  64,  80,  96, 112, 128, 144, -1, -1, -1, -1, -1, -1,
        -1, 160, 176, 192, 208, 224, 240,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
        -1, 160, 176, 192, 208, 224, 240,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
    ];

    parse_(msb, lsb, &HEX_LSB, &HEX_MSB)
}

pub fn parse_lower(msb: u8, lsb: u8) -> Option<u8> {
    #[rustfmt::skip]
    static HEX_LSB_LOWER: [i16; 256] = [
        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
         0,   1,   2,   3,   4,   5,   6,   7,   8,   9, -1, -1, -1, -1, -1, -1,
        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
        -1,  10,  11,  12,  13,  14,  15,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
    ];

    #[rustfmt::skip]
    static HEX_MSB_LOWER: [i16; 256] = [
        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
         0,  16,  32,  48,  64,  80,  96, 112, 128, 144, -1, -1, -1, -1, -1, -1,
        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
        -1, 160, 176, 192, 208, 224, 240,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
    ];

    parse_(msb, lsb, &HEX_LSB_LOWER, &HEX_MSB_LOWER)
}

pub fn parse_upper(msb: u8, lsb: u8) -> Option<u8> {
    #[rustfmt::skip]
    static HEX_LSB_UPPER: [i16; 256] = [
        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
         0,   1,   2,   3,   4,   5,   6,   7,   8,   9, -1, -1, -1, -1, -1, -1,
        -1,  10,  11,  12,  13,  14,  15,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
    ];

    #[rustfmt::skip]
    static HEX_MSB_UPPER: [i16; 256] = [
        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
         0,  16,  32,  48,  64,  80,  96, 112, 128, 144, -1, -1, -1, -1, -1, -1,
        -1, 160, 176, 192, 208, 224, 240,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
        -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1, -1, -1, -1, -1, -1, -1,
    ];

    parse_(msb, lsb, &HEX_LSB_UPPER, &HEX_MSB_UPPER)
}

/// The values in lut's must be in range of `i16::MIN..256`
#[allow(clippy::similar_names)]
fn parse_(msb: u8, lsb: u8, lut_lsb: &[i16; 256], lut_msb: &[i16; 256]) -> Option<u8> {
    let v = lut_msb[msb as usize] | lut_lsb[lsb as usize];
    if v < 0 {
        None
    } else {
        #[allow(clippy::cast_possible_truncation)]
        #[allow(clippy::cast_sign_loss)]
        Some(v as u8)
    }
}

pub fn to_hex_lower(v: u8) -> [u8; 2] {
    let helper = |x: u8| -> u8 {
        match x {
            number @ 0..=9 => number + b'0',
            letter @ 10..=15 => letter - 10 + b'a',
            _ => unreachable!(),
        }
    };

    let msb = (v & 0xf0) >> 4;
    let lsb = v & 0x0f;

    [helper(msb), helper(lsb)]
}

pub fn to_hex_upper(v: u8) -> [u8; 2] {
    let helper = |x: u8| -> u8 {
        match x {
            number @ 0..=9 => number + b'0',
            letter @ 10..=15 => letter - 10 + b'A',
            _ => unreachable!(),
        }
    };

    let msb = (v & 0xf0) >> 4;
    let lsb = v & 0x0f;

    [helper(msb), helper(lsb)]
}

#[cfg(test)]
mod tests {
    fn to_lower(v: u8) -> Option<u8> {
        match v {
            0..=9 => Some(b'0' + v),
            10..=15 => Some(b'a' + v - 10),
            _ => None,
        }
    }

    fn to_upper(v: u8) -> Option<u8> {
        match v {
            0..=9 => Some(b'0' + v),
            10..=15 => Some(b'A' + v - 10),
            _ => None,
        }
    }

    #[test]
    fn parse() {
        for i in 0..16 {
            for j in 0..16 {
                let lower_a = to_lower(i).unwrap();
                let lower_b = to_lower(j).unwrap();

                let from_lower = super::parse(lower_a, lower_b).unwrap();
                assert_eq!(from_lower, i * 16 + j);

                let upper_a = to_upper(i).unwrap();
                let upper_b = to_upper(j).unwrap();

                let from_upper = super::parse(upper_a, upper_b).unwrap();
                assert_eq!(from_upper, i * 16 + j);
            }
        }
    }

    #[test]
    fn parse_lower() {
        for i in 0..16 {
            for j in 0..16 {
                let lower_a = to_lower(i).unwrap();
                let lower_b = to_lower(j).unwrap();

                let from_lower = super::parse_lower(lower_a, lower_b).unwrap();
                assert_eq!(from_lower, i * 16 + j);

                let upper_a = to_upper(i).unwrap();
                let upper_b = to_upper(j).unwrap();

                let from_upper = super::parse_lower(upper_a, upper_b);
                if i < 10 && j < 10 {
                    // if we're dealing with `0..=9` then it'll parse correctly
                    assert_eq!(from_upper.unwrap(), i * 16 + j);
                } else {
                    assert!(from_upper.is_none());
                }
            }
        }
    }

    #[test]
    fn parse_upper() {
        for i in 0..16 {
            for j in 0..16 {
                let lower_a = to_lower(i).unwrap();
                let lower_b = to_lower(j).unwrap();

                let from_lower = super::parse_upper(lower_a, lower_b);
                if i < 10 && j < 10 {
                    // if we're dealing with `0..=9` then it'll parse correctly
                    assert_eq!(from_lower.unwrap(), i * 16 + j);
                } else {
                    assert!(from_lower.is_none());
                }

                let upper_a = to_upper(i).unwrap();
                let upper_b = to_upper(j).unwrap();

                let from_upper = super::parse_upper(upper_a, upper_b).unwrap();
                assert_eq!(from_upper, i * 16 + j);
            }
        }
    }
}
